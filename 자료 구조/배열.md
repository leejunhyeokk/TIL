# 배열

## 배열이란

### C 배열

- 연속적으로 저장된다.
- 크기가 고정되어 있다.
- 같은 타입의 데이터만 담을 수 있다.



### 파이썬 리스트(C의 배열 기반으로 만들어짐)

- 연속적 X / 레퍼런스로 데이터를 가리킨다.(저장의 개념 X)
- 자료들의 크기가 상관 없고 다양한 데이터를 저장할 수 있다.



### 배열 인덱스 접근

- C 배열의 인덱스 구하기 == 주소 + 데이터 크기 x 인덱스(i)

시간 복잡도 O(1)



### 배열 탐색

**접근**은 인덱스를 통해 값을 찾는 것

**탐색**은 특정 조건을 만족하는 값을 찾는 것

n개의 인덱스를 모두 탐색해야 할 수도 있다.

시간 복잡도 O(n)



## 정적 배열

- 크기 고정 (요소 수 제한)

배열 크기를 고정한 후 크기에 맞는 값만 넣는다.

배열을 늘리고 싶으면 배열 크기를 새롭게 고정한 후 새로운 배열에 새롭게 넣는다.

필요 이상으로 배열을 정한다면 낭비되는 공간이 많아진다. + 넣어도 되는 공간인지 의문



## 동적 배열

- 동적 배열: 크기 변동 (요소 수 계속 추가 가능) - 상황에 맞게 크기가 바뀐다. (개발자 입장에서는 굉장히 편하다.)
- 정적 배열로 만들어진 자료 구조
- 정적 배열의 크기를 상황에 맞게 조절한다.



### 추가 연산(append operation)

배열의 가장 끝에 새 연산을 넣는 것

- 정적 배열 남는 공간이 있을 때 (O1) - best 상황
- 정적 배열이 꽉 찾을 때 실행 (O(n)) - 새롭게 만들고 일일이 복사해서 넣어줘야 한다. - worst 상황



### 분할 상환 분석(Amortized Analysis)

- 같은 동작을 n번 했을 때 드는 시간이 X일 때 = 동작을 한 번 하는 데 걸린 시간: X/n
- 시간 복잡도를 평균으로 내서 말해주는 것(합리적으로 표현 가능) - 일종의 할부 개념



## 삽입 연산(insert operation)

#### 정적 배열에 남는 공간이 있을 때

- 특정 배열에 넣기 위해서는 그 뒤 배열을 모두 뒤로 밀어줘야 한다.

  최악의 경우 시간 복잡도 O(n)



#### 정적 배열이 찼을 때

- 새로운 배열을 만든 후 기존 배열들을 모두 복사해준 후 위의 일을 반복

  배열 만든 후 복사 O(n) + 배열 밀어주기 O(n) = 시간 복잡도 O(n)





## 삭제 연산

- 삭제하고 싶은 데이터 뒤에 있는 모든 데이터 요소들을 한 배열씩 앞으로 땡겨서 저장한다.



#### 맨 앞의 데이터를 지울 때

최악의 경우로 n - 1개의 요소들을 지워야 하기에 O(n)이 걸린다.



#### 맨 뒤 데이터를 지울 때

동적 배열의 사용 공간을 한 인덱스만 줄이면 된다.

배열과 데이터를 신경쓰지 않아도 되며 일정한 시간이 걸리기에 O(1)이다.





